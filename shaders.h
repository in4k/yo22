static const char *fragment_shaders[Prog_COUNT+1] = {
"uniform sampler2D _N;\n"
"vec4 n4(vec2 v){return texture2D(_N,(v+vec2(.5))/256.,-20.);}\n"
"float n(vec2 v){return n4(v).w;}\n"
"float vn(vec2 v,vec2 m) {\n"
"vec2 e=vec2(1.,0.),V=floor(v);v=fract(v);v*=v*(3.-2.*v);\n"
"return mix(mix(n(mod(V+e.yy,m)),n(mod(V+e.xy,m)),v.x),mix(n(mod(V+e.yx,m)),n(mod(V+e.xx,m)),v.x),v.y);\n"
"}\n"
"float fbm(vec2 v,float s) {\n"
"float r=0.,k=.5;\n"
"for(int i=0;i<12;++i,k*=.5,s*=2.)r+=k*vn(v*s,vec2(s));\n"
"return r;\n"
"}\n"
"void main() {\n"
"float height=fbm(gl_FragCoord.xy/4096.,7.);\n"
"height=pow(height, 3.) * 800.;\n"
"gl_FragColor=vec4(0., 0., height, 0.);\n"
"}\n"
, 
"uniform float _p;\n"
"uniform sampler2D _N,_T;\n"
"varying vec2 V;\n"
"float\n"
"Kr=0.01,\n"
"Ke=0.6,\n"
"Ks=1.0;\n"
"float transfer(float H,float w,vec2 ofs){\n"
"vec4 c=texture2D(_T,(gl_FragCoord.xy+ofs)/4096.,-20.);\n"
"float h=c.w+c.z,d=H-h;\n"
"if(d>0.)return -min(w,d);\n"
"else return min(c.w,-d);\n"
"}\n"
"void main(){\n"
"vec4 c=texture2D(_T,(gl_FragCoord.xy)/4096.,-20.);\n"
"// 1. transfer\n"
"vec4 c0=c;\n"
"float h=c.w+c.z,dw=0.;\n"
"vec2 e=vec2(1.,0.);\n"
"dw+=transfer(h,c.w,e.xy);\n"
"dw+=transfer(h,c.w,e.yx);\n"
"dw+=transfer(h,c.w,-e.xy);\n"
"dw+=transfer(h,c.w,-e.yx);\n"
"dw+=transfer(h,c.w,vec2(1.,1.));\n"
"dw+=transfer(h,c.w,vec2(1.,1.));\n"
"dw+=transfer(h,c.w,-vec2(1.,1.));\n"
"dw+=transfer(h,c.w,-vec2(1.,1.));\n"
"c.w+=dw/8.;\n"
"// 2. evaporate\n"
"dw=c.w*Ke;\n"
"c.z+=dw*Ks;\n"
"c.w-=dw;\n"
"// 3. rain\n"
"dw=Kr;\n"
"c.z-=dw*Ks;\n"
"c.w+=dw;\n"
"// 4. PROFIT\n"
"gl_FragColor=vec4(\n"
"//(mod(_p*20.,2.)*2.-1.)\n"
"1000.*(c.w-c0.w),\n"
"//c.w-Kr,\n"
"-1000.*(c.z-c0.z),\n"
"c.z,\n"
"c.w);\n"
"}\n"
, 
"uniform float _t,_p;\n"
"uniform vec2 _r;\n"
"uniform sampler2D _N,_T,_F;\n"
"varying vec2 V;\n"
"\n"
"#define STEPS 128\n"
"#define HIT_EPS .001\n"
"#define FAR 2000.\n"
"#define BOUNCES 6\n"
"\n"
"float t=_t;\n"
"\n"
"vec4 noise(vec2 p){return texture2D(_N,(p+.5)/1024.,-20.);}\n"
"\n"
"float h(vec2 p){\n"
"vec4 c=texture2D(_T,p/4096.,-20.);\n"
"return c.z;//+c.w*10.;\n"
"//return c.z;\n"
"}\n"
"float h2(vec2 p){\n"
"vec4 c=texture2D(_T,p/4096.,-20.);\n"
"//return c.z+c.w;\n"
"return c.z;\n"
"}\n"
"\n"
"vec3 terrain_normal(vec2 p){\n"
"vec2 e=vec2(.5,0.);\n"
"vec3 dx=vec3(2.*e.x,h(p+e.xy)-h(p-e.xy),0.);\n"
"vec3 dz=vec3(0.,h(p+e.yx)-h(p-e.yx),2.*e.x);\n"
"return normalize(cross(dz,dx));\n"
"}\n"
"\n"
"vec3 terrain_albedo(vec3 p){\n"
"#if 1\n"
"return vec3(.2);\n"
"#elif 0\n"
"float m10=mod(floor(p.x/10.)+floor(p.z/10.),2.);\n"
"float m100=mod(floor(p.x/100.)+floor(p.z/100.),2.);\n"
"float m1000=mod(floor(p.x/1000.)+floor(p.z/1000.),2.);\n"
"return vec3(m10,m100,m1000)*(.3+.7*mod(floor(p.x)+floor(p.z),2.));\n"
"#elif 1\n"
"float XZ=mod(floor(p.x/1.)+floor(p.z/1.),2.);\n"
"float Y=mod(floor(p.y),2.);\n"
"return vec3(.2+.5*Y+.3*XZ);\n"
"#else\n"
"return texture2D(_T,p.xz/4096.,-20.).xyw*10.;\n"
"#endif\n"
"}\n"
"//vec3 terrain_brdf(float s,vec3 p,vec3 n,vec3 inc,vec3 dir){}\n"
"vec3 terrain_bounce(float s,vec3 p,vec3 n,vec3 inc){\n"
"vec3 r=noise(vec2(s)).ywx*2.-vec3(1.);\n"
"return normalize(r*sign(dot(r,n)));\n"
"}\n"
"\n"
"#define DEF_TRACE(NAME_,FUNC_,STEPS_,HIT_EPS_) \\\n"
"float NAME_(vec3 O, vec3 D, float l, float lM){\\\n"
"float lp=l;\\\n"
"for(int i=0;i<STEPS_;++i){\\\n"
"vec3 p=O+D*l;\\\n"
"float dhit=HIT_EPS*l;\\\n"
"float d=FUNC_(p,D,dhit);\\\n"
"if(d<dhit){\\\n"
"for(int j=0;j<9;++j){\\\n"
"float lm=(l+lp)*.5;\\\n"
"p=O+D*lm;\\\n"
"d=FUNC_(p,D,dhit);\\\n"
"if(d<dhit)l=lm;else lp=lm;\\\n"
"}\\\n"
"break;\\\n"
"}\\\n"
"lp=l;\\\n"
"l+=d;\\\n"
"if(l>lM)return lM;\\\n"
"}\\\n"
"return l;\\\n"
"}\n"
"\n"
"float maxv(vec3 v){return max(v.x,max(v.y,v.z));}\n"
"float dbox(vec3 p,vec3 sz){\n"
"return maxv(abs(p)-sz);\n"
"}\n"
"\n"
"float dist_b0(vec3 p){\n"
"vec3 ofs=vec3(0., 200., -500.);\n"
"return length(p-ofs)-30.;\n"
"}\n"
"\n"
"float dist_b1(vec3 p){\n"
"vec3 ofs=vec3(0., 130., -500.);\n"
"return length(p-ofs-vec3(65.,0.,0.))-24.;\n"
"}\n"
"float dist_b2(vec3 p){\n"
"vec3 ofs=vec3(0., 130., -500.);\n"
"return length(p-ofs+vec3(65.,0.,0.))-20.;\n"
"}\n"
"\n"
"float dist_terrain(vec3 p,vec3 D,float dhit){\n"
"float H=h(p.xz);\n"
"return p.y-H;\n"
"}\n"
"\n"
"float dist_city(vec3 p, vec3 D, float dhit){\n"
"float SZ=10.;\n"
"vec2 cell=floor(p.xz/SZ);\n"
"vec2 cellc=cell*SZ + SZ/2.;\n"
"vec3 cellcenter=vec3(cellc.x, h(cellc), cellc.y);\n"
"vec4 crand=noise(cell);\n"
"return \n"
"dbox(p-cellcenter, vec3((.1+crand.x*.35)*SZ, 1.+crand.y*20., (.05+crand.z*.4)*SZ));\n"
"}\n"
"\n"
"mat3 geometry_material(vec3 p){\n"
"float terrain=dist_terrain(p,vec3(0.),0.);\n"
"float bld=dist_city(p,vec3(0.),0.);\n"
"float b0=dist_b0(p), b1 = dist_b1(p), b2 = dist_b2(p);\n"
"float mm=min(min(min(min(terrain,b0),b1),b2),bld);\n"
"\n"
"mat3 m=mat3(0.,0.,0.,0.,0.,0.,0.,0.,0.);\n"
"if(mm == bld) {\n"
"vec2 cell=floor(p.xz/100.);\n"
"vec4 crand=noise(cell);\n"
"float ff=mod(p.y/4.,1.);\n"
"m[0]=vec3(.2);//*(vec3(ff*.0)+1.*noise(floor(crand.yx*1024.)).wyx);\n"
"//m[1]=m[0] *0.1;\n"
"} else if(mm == b2) {\n"
"m[0]=vec3(1.);\n"
"m[1]=vec3(100.,0.,0.);\n"
"} else if(mm == b1) {\n"
"m[0]=vec3(1.);\n"
"m[1]=vec3(0.,100.,0.);\n"
"} else if(mm == b0) {\n"
"m[0]=vec3(1.);\n"
"m[1]=vec3(1000.);\n"
"} else {\n"
"m[0]=.2*terrain_albedo(p);\n"
"}\n"
"\n"
"return m;\n"
"}\n"
"\n"
"float geometry_world(vec3 p,vec3 D,float dhit){\n"
"float terrain=dist_terrain(p,D,dhit);\n"
"float bld=dist_city(p,D,dhit);\n"
"return min(min(min(min(terrain,dist_b0(p)),dist_b1(p)),dist_b2(p)),bld);\n"
"}\n"
"\n"
"float geometry_world_(vec3 p){return geometry_world(p,vec3(0.),.0);}\n"
"\n"
"vec3 geometry_normal(vec3 p){\n"
"vec2 e=vec2(.001,.0);\n"
"return normalize(vec3(\n"
"geometry_world_(p+e.xyy)-geometry_world_(p-e.xyy),\n"
"geometry_world_(p+e.yxy)-geometry_world_(p-e.yxy),\n"
"geometry_world_(p+e.yyx)-geometry_world_(p-e.yyx)\n"
"));\n"
"}\n"
"\n"
"vec3 geometry_bounce(float s,vec3 p,vec3 n,vec3 inc){\n"
"s*=1024.*1024.;\n"
"vec3 r=noise(vec2(mod(s,1024.),s/1024.)).ywx*2.-vec3(1.);\n"
"return normalize(r*sign(dot(r,n)));\n"
"}\n"
"\n"
"DEF_TRACE(trace_geometry,geometry_world,64,.01)\n"
"\n"
"void main(){\n"
"vec2 res=vec2(1280.,720.);\n"
"vec2 uv=gl_FragCoord.xy/res-vec2(.5);uv.x*=res.x/res.y;\n"
"//vec3 O=vec3(0.,150.,300.),D=normalize(vec3(uv,-2.));\n"
"vec3 O=vec3(sin(t*.01)*100.,50.,cos(t*.01)*300.),D=normalize(vec3(uv,-2.));\n"
"//vec3 O=vec3(sin(t)*1000.,50.,cos(t)*1000.),D=normalize(vec3(uv,-2.));\n"
"O.y+=h2(O.xz);\n"
"\n"
"//vec3 O=vec3(0.,0.,10.),D=normalize(vec3(uv,-2.));\n"
"\n"
"// FIXME replace with lens/sampler model\n"
"O+=noise(vec2(t*1000.)).xyz*.3;\n"
"\n"
"vec3 color=vec3(0.), cmask=vec3(1.);\n"
"for(int i=0;i<BOUNCES;++i){\n"
"vec3 albedo=vec3(0.), emission = vec3(1.);\n"
"float lg=trace_geometry(O, D, 0., FAR);\n"
"\n"
"// sky\n"
"if(lg >= FAR) {\n"
"emission=vec3(400.0) * 1.0 * pow(max(0.,dot(D,normalize(vec3(.1,.06,0.)))),20.);\n"
"albedo=vec3(0.);\n"
"} else {\n"
"vec3 p=O+D*lg;\n"
"//albedo=.2 * terrain_albedo(p);\n"
"//emission=vec3(.0);//p.x>1.?10.:0.,p.x<-1.?10.:0.,0.);\n"
"mat3 m=geometry_material(p);\n"
"albedo=m[0];\n"
"emission=m[1];\n"
"\n"
"vec3 n=geometry_normal(p);\n"
"O=p;\n"
"D=geometry_bounce(\n"
"float(i)/float(BOUNCES)+t+noise(gl_FragCoord.xy).z+noise(1024.*vec2(dot(D,p+t*247.))).w,\n"
"//float(i)/float(BOUNCES)+t*.01,//+p.x+p.y+p.z,\n"
"p,n,D);\n"
"}\n"
"\n"
"color +=cmask * emission;\n"
"cmask *=albedo;\n"
"if(dot(cmask,cmask) < .0001) break;\n"
"\n"
"/*\n"
"a-> b -> c\n"
"C=a.e + a.a * (b.e + b.a*(c.e + c.a * ambient))\n"
"*/\n"
"\n"
"#if 0\n"
"// terrain\n"
"vec3 p=O+D*lt;\n"
"if(p.y-h(p.xz)>HIT_EPS*lt){gl_FragColor=vec4(1.,0.,0.,1.);return;}\n"
"if(h(p.xz)>p.y){gl_FragColor=vec4(1.,0.,1.,1.);return;}\n"
"//gl_FragColor=l/2000.;//vec4((O+D*l).y/1000.);\n"
"vec3 n=terrain_normal(p.xz);\n"
"//vec3 color=vec3(-n.y, n.y, 0.);\n"
"color=terrain_albedo(p)*(max(0.,dot(n, normalize(vec3(1., 1., -.5))))+vec3(.05));\n"
"//vec3 color=max(0.,dot(n, normalize(vec3(cos(t*10.),1.,sin(t*20.)))))+vec3(.2);\n"
"//vec3 color=(O+D*l) / vec3(3000.,1000.,3000.);\n"
"#endif\n"
"}\n"
"\n"
"color=max(vec3(0.), color);\n"
"gl_FragColor=vec4(pow(color,vec3(1./2.2)),1.);\n"
"}\n"
, 
"uniform float _t,_p, _pt;\n"
"uniform vec2 _r;\n"
"uniform sampler2D _N,_T,_F;\n"
"varying vec2 V;\n"
"#if 1\n"
"void main(){\n"
"if(gl_FragCoord.y<16.){gl_FragColor=vec4(step(V.x*.5+.5,_p));return;}\n"
"gl_FragColor=texture2D(_F,gl_FragCoord.xy/_r,-20.)*.1/(1.+256.*_pt);\n"
"}\n"
"#else\n"
"float t=_t*.001;\n"
"float h(vec2 p){\n"
"vec4 c=texture2D(_T,p/4096.,-20.);\n"
"return c.z+c.w*10.;\n"
"//return c.z;\n"
"}\n"
"float h2(vec2 p){\n"
"vec4 c=texture2D(_T,p/4096.,-20.);\n"
"//return c.z+c.w;\n"
"return c.z;\n"
"}\n"
"vec3 n(vec2 p){\n"
"vec2 e=vec2(.5,0.);\n"
"vec3 dx=vec3(2.*e.x,h(p+e.xy)-h(p-e.xy),0.);\n"
"vec3 dz=vec3(0.,h(p+e.yx)-h(p-e.yx),2.*e.x);\n"
"return normalize(cross(dz,dx));\n"
"}\n"
"vec3 albedo(vec3 p){\n"
"#if 0\n"
"float m10=mod(floor(p.x/10.)+floor(p.z/10.),2.);\n"
"float m100=mod(floor(p.x/100.)+floor(p.z/100.),2.);\n"
"float m1000=mod(floor(p.x/1000.)+floor(p.z/1000.),2.);\n"
"return vec3(m10,m100,m1000)*(.3+.7*mod(floor(p.x)+floor(p.z),2.));\n"
"#elif 1\n"
"float XZ=mod(floor(p.x/1.)+floor(p.z/1.),2.);\n"
"float Y=mod(floor(p.y),2.);\n"
"return vec3(.2+.5*Y+.3*XZ);\n"
"#else\n"
"return texture2D(_T,p.xz/4096.,-20.).xyw*10.;\n"
"#endif\n"
"}\n"
"void main(){\n"
"if(gl_FragCoord.y<16.){gl_FragColor=vec4(step(V.x*.5+.5,_p));return;}\n"
"vec2 uv=gl_FragCoord.xy/_r-.5;uv.x*=_r.x/_r.y;\n"
"vec3 O=vec3(sin(t)*1000.,50.,cos(t)*1000.),D=normalize(vec3(uv,-2.));\n"
"//for(int i=0;i<16.\n"
"O.y+=h2(O.xz);\n"
"//vec3 O=vec3(sin(t)*1000.,600.,cos(t)*1000.),D=normalize(vec3(uv,-2.));\n"
"float l=0.,lp=l;\n"
"for(int i=0;i<128;++i){\n"
"vec3 p=O+D*l;\n"
"float d=p.y-h(p.xz);\n"
"if(d<.001*l) {\n"
"for(int j=0;j<9;++j){\n"
"float lm=(l+lp)*.5;\n"
"vec3 p=O+D*lm;\n"
"float d=p.y-h(p.xz);\n"
"if(d<.001*lm)l=lm;else lp=lm;\n"
"}\n"
"break;\n"
"}\n"
"lp=l;\n"
"//l+=max(20.,d*.1);\n"
"l+=d;\n"
"if(l>3000.)break;\n"
"}\n"
"if(l>3000.){gl_FragColor=vec4(0.);return;}\n"
"vec3 p=O+D*l;\n"
"if(p.y-h(p.xz)>.01*l){gl_FragColor=vec4(1.,0.,0.,1.);return;}\n"
"if(h(p.xz)>p.y){gl_FragColor=vec4(1.,0.,1.,1.);return;}\n"
"//gl_FragColor=l/2000.;//vec4((O+D*l).y/1000.);\n"
"vec3 n=n((O+D*l).xz);\n"
"//vec3 color=vec3(-n.y, n.y, 0.);\n"
"vec3 color=albedo(p)*(max(0.,dot(n, normalize(vec3(1., 1., -.5))))+vec3(.05));\n"
"//vec3 color=max(0.,dot(n, normalize(vec3(cos(t*10.),1.,sin(t*20.)))))+vec3(.2);\n"
"//vec3 color=(O+D*l) / vec3(3000.,1000.,3000.);\n"
"gl_FragColor=vec4(pow(color,vec3(1./2.2)),1.);\n"
"}\n"
"#endif\n"
, 
""};
